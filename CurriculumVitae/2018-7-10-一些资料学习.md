简单工厂模式
策略模式与工厂模式结合
decorate
装饰模式： 动态的给一个对象添加一些额外的职责，装饰模式比生成子类更加灵活
代理模式： 其他对象提供一种代理以控制这个对象的访问
原型模式： 创建对象的种类，并通过拷贝这些原型创建新的对象
模板方法模式： 定义操作中的算法骨架，将一些步骤延迟到子类中。
状态模式： 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类
适配器模式: 将一个类的接口转换成客户希望的另外一个接口，
组合模式： 
迭代器模式： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示
桥接模式： 抽象部分与它的实现部分分离，是他们都可以独立变化

开闭原则： 对于扩展是开放的 对于更改是封闭的
里氏替换原则： 如果软件实体使用的是一个父类的话，那么一定使用子类，而且它察觉不出父类对象和子类对象的区别(子类必须能替换掉他们的父类型)
迪米特法则： 如果两个类不必直接通信，那么这两个类就不应当直接发生相互作用。如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用


----nginx----
* 静态web服务器 反向代理服务器
* nginx -t 检测配置错误
* nginx -s stop 
* nginx -s reload 重新加载

        http {
            server_tokens off;//禁用版本号
            upstream tomcats {/负载均衡策略
                server 127.0.0.1:8080;
                server 127.0.0.1:8080;
                server 127.0.0.1:8080;
            }
            server {
                listen       80; //端口
                server_name  a.ttlsa.com; //DNS解析  C:\Windows\System32\drivers\etc\hosts
                location / { //反向代理 也可以正向代理
                        proxy_set_header X-Forwarded-Host $host;
                        proxy_set_header X-Forwarded-Server $host;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_pass http://tomcats;
                }
            }
                //静态网页地址
            server {
                server_name b.ttlsa.com c.ttlsa.com;
                listen 127.0.0.1:80;
                root data/site/b.ttlsa.com;
                access_log data/logs/nginx/b.ttlsa.com-access.log main;
                location / {

                }
            }
        }


plugin:
1. Angular Language Service
2. Angular v6 Snippets
3. Auto Close Tag
4. Auto Import
5. ESLint
6. Full React/React Native/React Router/Redux/GraphQL/ES7/Testing/PropTypes snippets
7. JSON Tools
8. Markdown All in One
9. Path Intellisense
10. React-Native/React/Redux snippets for es6/es7
11. Reactjs code snippets
12. TSLint